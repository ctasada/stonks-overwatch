{% load static %}
<!-- TableExport dependencies -->
<script src="{% static 'tableexport.jquery.plugin/libs/FileSaver/FileSaver.min.js' %}"></script>
<script src="{% static 'tableexport.jquery.plugin/tableExport.min.js' %}"></script>
<!-- Bootstrap Table Extensions -->
<script src="{% static 'bootstrap-table/dist/extensions/export/bootstrap-table-export.min.js' %}"></script>
<script src="{% static 'bootstrap-table/dist/extensions/sticky-header/bootstrap-table-sticky-header.min.js' %}"></script>

<script>
    $(document).ready(function() {
        // Constants for height calculations
        var VIEWPORT_HEIGHT_OFFSET = 100; // Accounts for navbar, padding, and margins above scrollable area
        var TABLE_CONTAINER_PADDING = 55; // Accounts for page title, margins, and spacing below table container
        var MIN_TABLE_HEIGHT = 400; // Minimum table height in pixels to ensure usability

        // Function to calculate dynamic table height based on available screen space
        function calculateTableHeight() {
            var $table = $('#{{ table_id }}');
            var $scrollableArea = $('.scrollable-area');

            // Calculate the expected scrollable area height based on viewport
            var viewportHeight = $(window).height();
            var expectedScrollableHeight = viewportHeight - VIEWPORT_HEIGHT_OFFSET;
            var scrollableAreaTop = $scrollableArea.offset().top;
            var scrollableAreaBottom = scrollableAreaTop + expectedScrollableHeight;

            var $tableContainer = $table.data('bootstrap.table')
                ? $table.closest('.bootstrap-table')
                : $table.parent();

            var availableHeight;

            // If table is initialized, measure from the Bootstrap Table wrapper
            if ($table.data('bootstrap.table') && $tableContainer.length) {
                var bootstrapTableTop = $tableContainer.offset().top;
                availableHeight = scrollableAreaBottom - bootstrapTableTop;
            } else {
                // Fallback calculation for before initialization
                var tableContainerTop = $tableContainer.offset().top;
                availableHeight = scrollableAreaBottom - tableContainerTop - TABLE_CONTAINER_PADDING;
            }

            return Math.max(availableHeight, MIN_TABLE_HEIGHT);
        }

        // Initialize Bootstrap Table with sticky-header extension
        var $table = $('#{{ table_id }}');
        var navbarHeight = $('.navbar').outerHeight() || 0;

        var tableHeight = calculateTableHeight();

        // Initialize table with all options including sticky-header
        $table.bootstrapTable({
            search: true,
            pagination: true,
            paginationLoop: false,
            pageList: [10, 25, 50, 100, 200, 'All'],
            paginationParts: ['pageInfo', 'pageList', 'pageSize'],
            pageSize: 10,
            sortable: true,
            sortOrder: 'desc',
            sortName: '{{ sort_name|default:"date" }}',
            icons: 'icons',
            iconsPrefix: 'bi',
            fixedScroll: true,
            classes: 'table table-hover',
            showColumns: true,
            showExport: true,
            exportTypes: ['csv'],
            exportOptions: {
                fileName: '{{ export_filename }}',
                ignoreColumn: []
            },
            stickyHeader: true,
            stickyHeaderOffsetY: navbarHeight,
            height: tableHeight
        });

        // Recalculate height on window resize
        var resizeTimeout;
        var resizeHandler = function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                var newHeight = calculateTableHeight();
                $table.bootstrapTable('resetView', { height: newHeight });
            }, 100);
        };
        $(window).on('resize', resizeHandler);

        // Remove overflow from scrollable-area to allow sticky positioning and recalculate height
        setTimeout(function() {
            $('.scrollable-area').css('overflow', 'visible');
            setTimeout(function() {
                var updatedHeight = calculateTableHeight();
                $table.bootstrapTable('resetView', { height: updatedHeight });
            }, 100);
        }, 300);

        // Fix dropdown positioning by triggering Popper recalculation
        var observer = new MutationObserver(function(mutations) {
            for (const mutation of mutations) {
                if (mutation.attributeName === 'class') {
                    var $target = $(mutation.target);
                    if ($target.hasClass('dropdown-menu') && $target.hasClass('show')) {
                        // Trigger resize and scroll events to force Popper to recalculate position
                        setTimeout(function() {
                            window.dispatchEvent(new Event('resize'));
                        }, 10);
                        setTimeout(function() {
                            window.dispatchEvent(new Event('scroll'));
                        }, 20);
                    }
                }
            }
        });

        // Function to clean up all observers and event handlers
        function cleanup() {
            // Disconnect dropdown observer
            if (observer && typeof observer.disconnect === 'function') {
                observer.disconnect();
                observer = null;
            }

            // Disconnect removal observer
            if (removalObserver && typeof removalObserver.disconnect === 'function') {
                removalObserver.disconnect();
                removalObserver = null;
            }

            // Remove resize event handler
            $(window).off('resize', resizeHandler);
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
                resizeTimeout = null;
            }
        }

        // Start observing after Bootstrap Table initializes
        setTimeout(function() {
            $('.bootstrap-table .dropdown-menu').each(function() {
                observer.observe(this, { attributes: true, attributeFilter: ['class'] });
            });
        }, 500);

        // Cleanup: Disconnect observer on page unload
        $(window).on('beforeunload', function() {
            cleanup();
        });

        // Cleanup: Disconnect observer if table is destroyed
        $table.on('destroy.bs.table', function() {
            cleanup();
        });

        // Cleanup: Disconnect observer if table container is removed from DOM
        var $tableContainer = $table.closest('.bootstrap-table').length
            ? $table.closest('.bootstrap-table')
            : $table.parent();

        // Monitor for table removal using MutationObserver on parent
        var removalObserver = new MutationObserver(function(mutations) {
            for (const mutation of mutations) {
                for (const removedNode of mutation.removedNodes) {
                    // Check if removed node is the table itself, or contains the table (only for Element nodes)
                    if (removedNode === $table[0] ||
                        (removedNode.nodeType === 1 && typeof removedNode.contains === 'function' && removedNode.contains($table[0]))) {
                        cleanup();
                        return;
                    }
                }
            }
        });

        // Observe the parent container for table removal
        if ($tableContainer.length && $tableContainer[0].parentNode) {
            removalObserver.observe($tableContainer[0].parentNode, {
                childList: true,
                subtree: true
            });
        }
    });
</script>
